---
layout: post
title: "Black Box Testing Middleware Services"
date: 2012-05-25 14:14
comments: true
categories: [testing]
author: Jason Baker <jbaker@vast.com>
---

We've developed a [middleware](http://en.wikipedia.org/wiki/Middleware) web services testing framework that simplifies creating, running, and updating regression test suites via HTTP request/response recording. 

This test framework allows our developers to quickly develop and run [black box](http://en.wikipedia.org/wiki/Black_box_testing) regression test suites for internal services that often rely on dozens of other internal and third party services. Such regression suites enable our developers and QA testers to maximize test coverage with minimal effort, and clear the way for refactoring. 

<!-- more -->

We prefer to use [REST](http://en.wikipedia.org/wiki/Representational_state_transfer) more often than not, and as such, many of our integration points in our legacy middleware are incredibly simple [Apache Http Client (3.1)](http://hc.apache.org/httpclient-3.x/) usages, like this:

``` java
HttpMethod method = new GetMethod(query);
HttpClient client = new HttpClient();
client.executMethod(method)
```

Our test framework provides HTTPClient and HTTPMethod subclasses that give us our hooks to do our magic:

``` java
HttpMethod method = VastHttpClient.createGetMethod(query);
VastHttpClient client = VastHttpClient.factory();
client.executMethod(method)
```

Our HttpClient subclass is very straight forward. The factory method determines a VastHttpClient subclass based on a system property, and our createGetMethod method wraps an instance of Apache's GetMethod class in our own wrapper.  

``` java
package com.vast.mtf.mock.http;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpException;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.httpclient.methods.PutMethod;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;

/**
 * Copyright Vast 2012. All Rights Reserved.
 *
 * http://www.vast.com
 *
 * A subclass of HttpClient (3.1) that gives us a hook into providing alternative implementations of
 * HttpClient, such as implementations that return Mock Data or log exchanges.
 * <p/>
 * Code using VastHttpClient is expected to instantiate a VastHttpClient instance with the factory() method,
 * and use the createGetMethod(), createPutMethod, etc methods to create HttpMethod instances.
 * <p/>
 * You can substitute your own VastHttpClient and VastMethodWrapper implementations by overriding the
 * following system properties: "vast.http.client.class.name", and "vast.http.wrapper.class.name"
 * Author: jbaker (jbaker@vast.com)
 */
public class VastHttpClient extends HttpClient {
    protected static final Logger logger = LoggerFactory.getLogger(VastHttpClient.class);

    protected VastHttpClient() {
    }

    public static final String VAST_HTTP_CLIENT_SYSTEM_PROPERTY = "vast.http.client.class.name";
    public static final String DEFAULT_HTTP_CLIENT_CLASS_NAME = "com.vast.mtf.mock.http.VastHttpClient";

    public static final String VAST_HTTP_METHOD_WRAPPER_SYSTEM_PROPERTY = "vast.http.wrapper.class.name";
    public static final String DEFAULT_HTTP_METHOD_WRAPPER_CLASS_NAME = "com.vast.mtf.mock.http.VastMethodWrapper";

    protected static Object createClassInstance(String className, String defaultClassName, String description) {
        if (StringUtils.isEmpty(className)) {
            className = defaultClassName;
        }
        try {
            logger.debug("Instantiating " + description + " with class type: " + className);
            return Class.forName(className).newInstance();
        } catch (Exception e) {
            logger.error("Could not instantiate " + description + " of type: " + className, e);
            throw new RuntimeException("Could not instantiate " + description + " of type: " + className, e);
        }
    }

    public static VastHttpClient factory() {
        return (VastHttpClient) createClassInstance(System.getProperty(VAST_HTTP_CLIENT_SYSTEM_PROPERTY),
                DEFAULT_HTTP_CLIENT_CLASS_NAME, "VastHttpClient");
    }

    protected static VastMethodWrapper createWrapper(HttpMethod method) {
        VastMethodWrapper wrapper = (VastMethodWrapper) createClassInstance(System.getProperty(VAST_HTTP_METHOD_WRAPPER_SYSTEM_PROPERTY),
                DEFAULT_HTTP_METHOD_WRAPPER_CLASS_NAME, "VastMethodWraper");
        wrapper.setInnerMethod(method);
        return wrapper;
    }

    /**
     * Creates a GetMethod instance to be used with a VastHttpClient instance generated by VastHttpClient.factory()
     */
    public static HttpMethod createGetMethod(String query) {
        return createWrapper(new GetMethod(query));
    }

    /**
     * Creates a PostMethod instance to be used with a VastHttpClient instance generated by VastHttpClient.factory()
     */
    public static HttpMethod createPostMethod() {
        return createWrapper(new PostMethod());
    }

    /**
     * Creates a PutMethod instance to be used with a VastHttpClient instance generated by VastHttpClient.factory()
     */
    public static HttpMethod createPutMethod() {
        return createWrapper(new PutMethod());
    }

    /**
     * Creates a GetMethod instance to be used with a VastHttpClient instance generated by VastHttpClient.factory()
     */
    public static HttpMethod createGetMethod(String query) {
        return createWrapper(new GetMethod(query));
    }

    /**
     * Creates a PostMethod instance to be used with a VastHttpClient instance generated by VastHttpClient.factory()
     */
    public static HttpMethod createPostMethod(String path) {
        return createWrapper(new PostMethod(path));
    }

    /**
     * Creates a PutMethod instance to be used with a VastHttpClient instance generated by VastHttpClient.factory()
     */
    public static HttpMethod createPutMethod(String query) {
        return createWrapper(new PutMethod(query));
    }
    
    @Override
    public int executeMethod(HttpMethod method) throws IOException, HttpException {
        if (method instanceof VastMethodWrapper) {
            return super.executeMethod(((VastMethodWrapper) method).getInnerMethod());
        }
        return super.executeMethod(method);
    }

    public void setDisableLogging(boolean disableLogging) {
        this.disableLogging = disableLogging;
    }
}
```

Our basic HTTPMethod wrapper class is a simple [delegating](http://en.wikipedia.org/wiki/Delegation_pattern) wrapper around the original HTTPMethod instance: 

``` java
package com.vast.mtf.mock.http;

import org.apache.commons.httpclient.*;
import org.apache.commons.httpclient.auth.AuthState;
import org.apache.commons.httpclient.params.HttpMethodParams;

import java.io.IOException;
import java.io.InputStream;

/**
 * Copyright Vast 2012. All Rights Reserved.
 *
 * http://www.vast.com
 * 
 * A simple delegating HttpMethod wrapper class that delegates all actions to the innerMethod instance.
 * Author: jbaker (jbaker@vast.com)
 */
public class VastMethodWrapper implements HttpMethod {

    protected HttpMethod innerMethod = null;

    public VastMethodWrapper() {
    }

    public void setInnerMethod(HttpMethod innerMethod) {
        this.innerMethod = innerMethod;
    }

    public HttpMethod getInnerMethod() {
        return innerMethod;
    }

    @Override
    public void abort() {
        innerMethod.abort();
    }

    @Override
    public String getName() {
        return innerMethod.getName();
    }

    @Override
    public HostConfiguration getHostConfiguration() {
        return innerMethod.getHostConfiguration();
    }

    @Override
    public void setPath(String path) {
        innerMethod.setPath(path);
    }

    @Override
    public String getPath() {
        return innerMethod.getPath();
    }

    @Override
    public URI getURI() throws URIException {
        return innerMethod.getURI();
    }

    @Override
    public void setURI(URI uri) throws URIException {
        innerMethod.setURI(uri);
    }

    @Override
    public void setStrictMode(boolean strictMode) {
        innerMethod.setStrictMode(strictMode);
    }

    @Override
    public boolean isStrictMode() {
        return innerMethod.isStrictMode();
    }

    @Override
    public void setRequestHeader(String headerName, String headerValue) {
        innerMethod.setRequestHeader(headerName, headerValue);
    }

    @Override
    public void setRequestHeader(Header header) {
        innerMethod.setRequestHeader(header);
    }

    @Override
    public void addRequestHeader(String headerName, String headerValue) {
        innerMethod.addRequestHeader(headerName, headerValue);
    }

    @Override
    public void addRequestHeader(Header header) {
        innerMethod.addRequestHeader(header);
    }

    @Override
    public Header getRequestHeader(String headerName) {
        return innerMethod.getRequestHeader(headerName);
    }

    @Override
    public void removeRequestHeader(String headerName) {
        innerMethod.removeRequestHeader(headerName);
    }

    @Override
    public void removeRequestHeader(Header header) {
        innerMethod.removeRequestHeader(header);
    }

    @Override
    public boolean getFollowRedirects() {
        return innerMethod.getFollowRedirects();
    }

    @Override
    public void setFollowRedirects(boolean followRedirects) {
        innerMethod.setFollowRedirects(followRedirects);
    }

    @Override
    public void setQueryString(String queryString) {
        innerMethod.setQueryString(queryString);
    }

    @Override
    public void setQueryString(NameValuePair[] params) {
        innerMethod.setQueryString(params);
    }

    @Override
    public String getQueryString() {
        return innerMethod.getQueryString();
    }

    @Override
    public Header[] getRequestHeaders() {
        return innerMethod.getRequestHeaders();
    }

    @Override
    public Header[] getRequestHeaders(String headerName) {
        return innerMethod.getRequestHeaders(headerName);
    }

    @Override
    public boolean validate() {
        return innerMethod.validate();
    }

    @Override
    public int getStatusCode() {
        return innerMethod.getStatusCode();
    }

    @Override
    public String getStatusText() {
        return innerMethod.getStatusText();
    }

    @Override
    public Header[] getResponseHeaders() {
        return innerMethod.getResponseHeaders();
    }

    @Override
    public Header getResponseHeader(String headerName) {
        return innerMethod.getResponseHeader(headerName);
    }

    @Override
    public Header[] getResponseHeaders(String headerName) {
        return innerMethod.getResponseHeaders(headerName);
    }

    @Override
    public Header[] getResponseFooters() {
        return innerMethod.getResponseFooters();
    }

    @Override
    public Header getResponseFooter(String footerName) {
        return innerMethod.getResponseFooter(footerName);
    }

    @Override
    public byte[] getResponseBody() throws IOException {
        return innerMethod.getResponseBody();
    }

    @Override
    public String getResponseBodyAsString() throws IOException {
        return innerMethod.getResponseBodyAsString();
    }

    @Override
    public InputStream getResponseBodyAsStream() throws IOException {
        return innerMethod.getResponseBodyAsStream();
    }

    @Override
    public boolean hasBeenUsed() {
        return innerMethod.hasBeenUsed();
    }

    @Override
    public int execute(HttpState state, HttpConnection connection) throws HttpException, IOException {
        return innerMethod.execute(state, connection);
    }

    @Override
    public void recycle() {
        innerMethod.recycle();
    }

    @Override
    public void releaseConnection() {
        innerMethod.releaseConnection();
    }

    @Override
    public void addResponseFooter(Header footer) {
        innerMethod.addResponseFooter(footer);
    }

    @Override
    public StatusLine getStatusLine() {
        return innerMethod.getStatusLine();
    }

    @Override
    public boolean getDoAuthentication() {
        return innerMethod.getDoAuthentication();
    }

    @Override
    public void setDoAuthentication(boolean doAuthentication) {
        innerMethod.setDoAuthentication(doAuthentication);
    }

    @Override
    public HttpMethodParams getParams() {
        return innerMethod.getParams();
    }

    @Override
    public void setParams(HttpMethodParams params) {
        innerMethod.setParams(params);
    }

    @Override
    public AuthState getHostAuthState() {
        return innerMethod.getHostAuthState();
    }

    @Override
    public AuthState getProxyAuthState() {
        return innerMethod.getProxyAuthState();
    }

    @Override
    public boolean isRequestSent() {
        return innerMethod.isRequestSent();
    }
}
```

VastHTTPClient and VastMethodWrapper give us our key test framework [hooks](http://en.wikipedia.org/wiki/Hooking) into our service client code. With these hooks in place we are able to substitute differing HTTPClient and HTTPMethod implementations. 

We've developed three implementations, the simple implementation (shown above) simply uses apache's HTTPClient default behavior. The other two implementations are key to our testing framework: one implementation records http request and response data as the middleware runs, and another implementation replays previously recorded data back to the system. 

To create tests for the middleware framework, our developers or QA testers simply start an instance of our middleware in "record" mode, and fire client requests at the system. The system then executes the client request and logs HTTP interactions between it and other services to a specified mock data log file, one log file per request. Afterward, request data and recorded HTTP interaction data are paired together in a regression test suite that we drive with TestNG.

When tests are run, our test framework's test suite starts the service in "playback" mode. Client requests are fired at the system, along with details about which HTTP interaction log file to use for playing back previously recorded interactions. While processing the request, the test framework's playback implementation skips calling out to actual services, and instead simply returns previously recorded data. This allows the system to continue processing the request in the exact way it was processed before, even if request data would be considered out-of-date by external services or if some of those services are unavailable. 

The playback processing mode also dumps a "playback interaction" log file that contains the request data collected during playback, as well as the mock results fed back to the system from the original file. This makes our test suite verification of proper system execution very simple. We simply [diff](http://en.wikipedia.org/wiki/Diff) the original recorded interaction logfile and the "playback" interaction logfile. This verification ensures us that our system has not changed the way it parameterizes any HTTP calls it makes. 

We've developed similar subclass factory/wrapper patterns for our email subsystems and servlet responses, so our test suite verification also verifies that our system is sending the same emails, and responding with the same responses when tests are run in the future. 

As a big data company focused on car and real estate sales, most of our data is transient and/or mutable in nature as time progresses. Data about a car progresses from being listed, to being sold, to being archived or expunged from our systems. This can be a problem for a developer attempting to re-record an interaction with test data that's several months old. To combat this problem we've added hooks to our framework that enable us to selectively re-record portions of a request's lifecycle. Our developers can specify which downstream HTTP requests execute, and which previously-recorded HTTP responses to playback without an actual HTTP call. This simplifies updating a test case for a change that affects one out of dozens of downstream HTTP calls, and reduces churn caused by old data preventing re-recording. 

Our middleware testing framework is no substitute for adequate [unit test](http://en.wikipedia.org/wiki/Unit_tests) and/or [integration test](http://en.wikipedia.org/wiki/Integration_test) coverage, but it enables developers to quickly develop regression test suites that ensure increased code coverage. Increased code coverage from tests, no matter the source, translates into catching refactoring and feature change side effects sooner. 
